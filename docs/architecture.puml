@startuml noise_encoder
title Noise Encoder Architecture

skinparam rectangle {
    BackgroundColor LightBlue
    BorderColor DarkBlue
}

rectangle "Input" as input {
    card "r (noise ref)\n[B, 1, F, T_ref]" as r
}

rectangle "Preprocessing" as preprocess {
    card "Split Real/Imag\n[B, 2, F, T_ref]" as split
}

rectangle "Conv Layers" as convs {
    card "Conv2d(2→64)\nGroupNorm + SiLU" as conv1
    card "Conv2d(64→128)\nGroupNorm + SiLU" as conv2
    card "Conv2d(128→256)\nGroupNorm + SiLU" as conv3
    card "Conv2d(256→512)\nGroupNorm + SiLU" as conv4
}

rectangle "Pooling" as pool {
    card "AdaptiveAvgPool2d\n[B, 512, 4, 1]" as avgpool
    card "Flatten\n[B, 2048]" as flatten
}

rectangle "FC Layers" as fc {
    card "Linear(2048→512)\nSiLU" as fc1
    card "Linear(512→512)" as fc2
}

rectangle "Output" as output {
    card "z_r\n[B, 512]" as zr
}

r --> split
split --> conv1
conv1 --> conv2
conv2 --> conv3
conv3 --> conv4
conv4 --> avgpool
avgpool --> flatten
flatten --> fc1
fc1 --> fc2
fc2 --> zr

@enduml


@startuml z_injection
title Noise Embedding Injection (Add Mode)

skinparam rectangle {
    BackgroundColor LightYellow
    BorderColor Orange
}

rectangle "Time Embedding Path" as time_path {
    card "t (diffusion time)" as t
    card "GaussianFourierProjection\n[B, 256]" as fourier
    card "Linear + SiLU + Linear\n[B, 512]" as time_mlp
    card "temb [B, 512]" as temb
}

rectangle "Noise Embedding Path" as noise_path {
    card "z_r [B, 512]" as zr
    card "Linear + SiLU + Linear\n[B, 512]" as noise_proj
    card "noise_emb [B, 512]" as noise_emb
}

rectangle "Combination" as combine {
    card "temb = temb + noise_emb" as add
    card "combined_emb [B, 512]" as combined
}

rectangle "ResBlocks" as resblocks {
    card "ResBlock 1\nh = h + Dense(combined_emb)" as res1
    card "ResBlock 2\nh = h + Dense(combined_emb)" as res2
    card "..." as dots
    card "ResBlock N\nh = h + Dense(combined_emb)" as resn
}

t --> fourier
fourier --> time_mlp
time_mlp --> temb
temb --> add

zr --> noise_proj
noise_proj --> noise_emb
noise_emb --> add

add --> combined
combined --> res1
combined --> res2
combined --> dots
combined --> resn

@enduml


@startuml z_injection_film
title Noise Embedding Injection (FiLM Mode)

skinparam rectangle {
    BackgroundColor LightGreen
    BorderColor DarkGreen
}

rectangle "Time Embedding" as time_emb {
    card "t → Fourier → MLP" as t_process
    card "temb [B, 512]" as temb
}

rectangle "Noise Embedding" as noise_emb {
    card "z_r [B, 512]" as zr
    card "gamma = Linear(z_r)" as gamma_proj
    card "beta = Linear(z_r)" as beta_proj
}

rectangle "FiLM Modulation" as film {
    card "temb_new = gamma * temb + beta" as film_op
}

rectangle "To ResBlocks" as output {
    card "modulated_emb" as out
}

t_process --> temb
zr --> gamma_proj
zr --> beta_proj
temb --> film_op
gamma_proj --> film_op
beta_proj --> film_op
film_op --> out

@enduml


@startuml full_architecture
title Noise-Conditioned SGMSE+ Full Architecture

skinparam rectangle {
    BackgroundColor<<encoder>> LightBlue
    BackgroundColor<<backbone>> LightYellow
    BackgroundColor<<input>> LightGray
    BackgroundColor<<output>> LightGreen
}

rectangle "Inputs" <<input>> as inputs {
    card "x_t\n(corrupted signal)\n[B, 1, F, T]" as xt
    card "y\n(noisy observation)\n[B, 1, F, T]" as y
    card "r\n(noise reference)\n[B, 1, F, T_ref]" as r
    card "t\n(diffusion time)\n[B]" as t
}

rectangle "Noise Encoder" <<encoder>> as encoder {
    card "Conv Layers\n↓\nAdaptivePool\n↓\nFC Layers" as enc_layers
    card "z_r [B, 512]" as zr
}

rectangle "Time Processing" <<encoder>> as time_proc {
    card "Fourier + MLP" as time_mlp
    card "temb [B, 512]" as temb
}

rectangle "Conditioning Fusion" as fusion {
    card "temb + z_r\nor\ngamma*temb + beta" as fuse
    card "combined_emb" as combined
}

rectangle "NCSN++ U-Net" <<backbone>> as unet {
    rectangle "Encoder Path" as enc_path {
        card "Conv 4→128" as conv_in
        card "ResBlock + Attn\n↓ Downsample" as down1
        card "ResBlock + Attn\n↓ Downsample" as down2
        card "..." as down_dots
    }

    rectangle "Bottleneck" as bottleneck {
        card "ResBlock + Attn + ResBlock" as bottle
    }

    rectangle "Decoder Path" as dec_path {
        card "..." as up_dots
        card "Upsample ↑\nResBlock + Attn" as up2
        card "Upsample ↑\nResBlock + Attn" as up1
        card "Conv 128→2" as conv_out
    }
}

rectangle "Output" <<output>> as output {
    card "score\n∇_x log p(x|y,z_r)\n[B, 1, F, T]" as score
}

r --> enc_layers
enc_layers --> zr
t --> time_mlp
time_mlp --> temb
zr --> fuse
temb --> fuse
fuse --> combined

xt --> conv_in
y --> conv_in

conv_in --> down1
down1 --> down2
down2 --> down_dots
down_dots --> bottle
bottle --> up_dots
up_dots --> up2
up2 --> up1
up1 --> conv_out
conv_out --> score

combined -[dashed]-> down1 : inject
combined -[dashed]-> down2 : inject
combined -[dashed]-> bottle : inject
combined -[dashed]-> up2 : inject
combined -[dashed]-> up1 : inject

@enduml


@startuml training_flow
title Training Data Flow

skinparam sequence {
    ArrowColor DarkBlue
    LifeLineBorderColor DarkBlue
}

participant "DataLoader" as data
participant "NoiseEncoder" as enc
participant "SDE" as sde
participant "ScoreNetwork" as net
participant "Loss" as loss

data -> data: Load (x, y) pair
data -> data: n = y - x (oracle noise)
data -> data: r = random_crop(n)
data -> enc: r (noise reference)
enc -> enc: z_r = encode(r)

data -> sde: x, y, t~U(0,1)
sde -> sde: mean, std = marginal_prob(x, y, t)
sde -> sde: x_t = mean + std * z

sde -> net: x_t, y, t, z_r
net -> net: score = forward(x_t, y, t, z_r)

net -> loss: score, z, std
loss -> loss: L = ||score * σ + z||²

@enduml


@startuml inference_flow
title Inference (Zero-shot Enhancement)

skinparam sequence {
    ArrowColor DarkGreen
    LifeLineBorderColor DarkGreen
}

participant "User" as user
participant "NoiseEncoder" as enc
participant "Sampler" as sampler
participant "ScoreNetwork" as net

user -> user: Record noise reference r\n(0.5~2 sec from environment)
user -> enc: r
enc -> user: z_r (noise embedding)

user -> sampler: y (noisy speech), z_r
sampler -> sampler: x_T ~ N(y, σ_T²)

loop t = T to 0
    sampler -> net: x_t, y, t, z_r
    net -> sampler: score
    sampler -> sampler: x_{t-1} = reverse_step(x_t, score)
end

sampler -> user: x_0 (enhanced speech)

@enduml
